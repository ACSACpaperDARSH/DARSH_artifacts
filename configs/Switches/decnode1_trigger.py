# auto-generated by CC_DecisionNode_OVS service
# Short python to implement Trigger.
# The following three items are important:
# 1. You must write the process_data(self) function
# 2. Read the input (from the Monitor) directly from the suricata log file
# 3. Call the self.active_conn method with the cc node number as a parameter.

import time
#Required import
from Trigger.trigger import Trigger

#Required class name that inherits Trigger
class MyTrigger(Trigger):  
    
    #Required function
    def process_data(self):
        #forever loop to process data
        numAlerts = 0
        #get the cc_node numbers
        nodes = self.get_cc_node_numbers()
        self.set_active_conn("eth0", disable_others=True)
        self.set_active_conn("eth1", disable_others=False)
        timestamp_list = []
        while True:
####Modify to process Monitor's data and Trigger a switch####
            # read a line of input (from Monitor's stdout)
            # data = self.read_input_line()
            with open('/tmp/suricata-out/fast.log', 'r') as f:
                data = f.readlines()[-1]
            print("READ: " + str(data))
            #if data yet exists, restart loop
            if data == None:
                continue
            if "1100001" in data and data[:26] not in timestamp_list:
                timestamp_list.append(data[:26])
                # if data exists, we know there was an alert; 
                # let's switch if there are more than 10 alerts
                numAlerts = numAlerts + 1
                if numAlerts == 20:
                    self.set_active_conn("eth0", disable_others=True)
                    self.set_active_conn("eth4", disable_others=False)
                    count = 1
                    while True:
                        time.sleep(1)
                        count = count + 1
                        if count == 30:
                            #set active node
                            self.set_active_conn("eth0", disable_others=True)
                            self.set_active_conn("eth2", disable_others=False)
                        if count == 60:
                            self.set_active_conn("eth0", disable_others=True)
                            self.set_active_conn("eth4", disable_others=False)
                            count = 1
####